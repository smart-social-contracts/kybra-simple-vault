
# Get the current principal
PRINCIPAL=$(dfx identity get-principal)

# Create a dedicated minting principal
MINTING_PRINCIPAL="aaaaa-aa"

# Deploy the ledger canister with explicit arguments
echo "Deploying ckbtc_ledger canister..."
dfx deploy --no-wallet ckbtc_ledger --argument="(variant { Init = record { minting_account = record { owner = principal \"$MINTING_PRINCIPAL\"; subaccount = null }; transfer_fee = 10; token_symbol = \"ckBTC\"; token_name = \"ckBTC Test\"; decimals = opt 8; metadata = vec {}; initial_balances = vec { record { record { owner = principal \"$PRINCIPAL\"; subaccount = null }; 1_000_000_000 } }; feature_flags = opt record { icrc2 = true }; archive_options = record { num_blocks_to_archive = 1000; trigger_threshold = 2000; controller_id = principal \"$PRINCIPAL\" } } })"

# Get the ledger canister ID
LEDGER_ID=$(dfx canister id ckbtc_ledger)

# Deploy the indexer canister with the ledger ID
echo "Deploying indexer canister..."
dfx deploy --no-wallet ckbtc_indexer --argument="(opt variant { Init = record { ledger_id = principal \"$LEDGER_ID\"; retrieve_blocks_from_ledger_interval_seconds = opt 1 } })"

# Deploy the vault canister
echo "Deploying vault canister..."
dfx deploy vault
VAULT_ID=$(dfx canister id vault)

# Set the ckBTC ledger canister principal in the vault canister
echo "Setting ckBTC ledger canister principal in vault..."
INDEXER_ID=$(dfx canister id ckbtc_indexer)
dfx canister call vault set_canister '("ckBTC ledger", principal "'"$LEDGER_ID"'")'
dfx canister call vault set_canister '("ckBTC indexer", principal "'"$INDEXER_ID"'")'

dfx canister call vault status
dfx canister call ckbtc_ledger icrc1_transfer '(record {
	to = record {
		owner = principal "'"$VAULT_ID"'";
		subaccount = null
	};
	amount = 1000;
	fee = null;
	memo = null;
	from_subaccount = null;
	created_at_time = null
})'

dfx canister call vault update_transaction_history




dfx canister call ckbtc_ledger icrc1_transfer '(record {
	to = record {
		owner = principal "br5f7-7uaaa-aaaaa-qaaca-cai";
		subaccount = null
	};
	amount = 1002;
	fee = null;
	memo = null;
	from_subaccount = null;
	created_at_time = null
})'
dfx canister call ckbtc_ledger icrc1_transfer '(record {
	to = record {
		owner = principal "br5f7-7uaaa-aaaaa-qaaca-cai";
		subaccount = null
	};
	amount = 1003;
	fee = null;
	memo = null;
	from_subaccount = null;
	created_at_time = null
})'
dfx canister call ckbtc_ledger icrc1_transfer '(record {
	to = record {
		owner = principal "br5f7-7uaaa-aaaaa-qaaca-cai";
		subaccount = null
	};
	amount = 1004;
	fee = null;
	memo = null;
	from_subaccount = null;
	created_at_time = null
})'
dfx canister call ckbtc_ledger icrc1_transfer '(record {
	to = record {
		owner = principal "br5f7-7uaaa-aaaaa-qaaca-cai";
		subaccount = null
	};
	amount = 1005;
	fee = null;
	memo = null;
	from_subaccount = null;
	created_at_time = null
})'
dfx canister call ckbtc_ledger icrc1_transfer '(record {
	to = record {
		owner = principal "br5f7-7uaaa-aaaaa-qaaca-cai";
		subaccount = null
	};
	amount = 1006;
	fee = null;
	memo = null;
	from_subaccount = null;
	created_at_time = null
})'



dfx canister call vault update_transaction_history


dfx canister call vault transfer '(principal "'"$PRINCIPAL"'", 100)'




The oldest_tx_id field in the response is meant to help with this - it tells you the ID of the oldest transaction in the current batch, which you can use as the start parameter for your next query to fetch the next (older) batch.

A typical pagination flow would look like:

CopyInsert
1. Get first page: start = null, max_results = 10
   → Returns transactions with IDs 50, 49, 48... 41 and oldest_tx_id = 41

2. Get second page: start = opt 41, max_results = 10
   → Returns transactions with IDs 40, 39, 38... 31 and oldest_tx_id = 31 

3. And so on...
This approach is beneficial because:

The most common case (getting the latest transactions) is easy - just use start = null
You don't need to know the latest transaction ID upfront
The pagination tokens (transaction IDs) are stable and won't shift if new transactions arrive
It's a bit unintuitive at first, but it works well for chronological data where you typically want newest items first.